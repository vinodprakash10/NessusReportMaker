package sample;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Created by ShiPC on 1/18/2017.
 */
public class Vulnerability implements Comparable<Vulnerability> {
    //    these are the properties of a vulnerability
    public String Port = "@@@NA";
    public String pluginName = "@@@NA";
    public String riskFactor = "@@@NA";
    public String solution = "@@@NA";
    public String synopsis = "@@@NA";
    public String description = "@@@NA";
    public String cvssBaseScore = "@@@NA";
    public String cvssTempScore = "@@@NA";
    public List<String> IPs = new LinkedList<>();

    //    this determines weather to show IP, MAC or NetBIOS of the System in Report.
    public static boolean showIP = true;
    public static boolean showMAC = false;
    public static boolean showNetBios = false;
    public static boolean showNA = true;

    //    these is the list of vulnerabilities which are not required in the report
    private static List<String> notNeededVulns = new LinkedList<String>(Arrays.asList(
            "SSL Self-Signed Certificate",
            "SNMP 'GETBULK' Reflection DDoS",
            "SSL Certificate Signed Using Weak Hashing Algorithm",
            "OpenSSL SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG Session Resume Ciphersuite Downgrade Issue"
    ));

    //    Vulnerablity Constructer
    public Vulnerability() {
    }

    //    Vulnerablity Constructer
    public Vulnerability(Vulnerability v) {
        Port = v.Port;
        pluginName = v.pluginName;
        riskFactor = v.riskFactor;
        solution = v.solution;
        synopsis = v.synopsis;
        description = v.description;
        cvssBaseScore = v.cvssBaseScore;
        cvssTempScore = v.cvssTempScore;
        IPs = v.IPs;

    }

    //    Vulnerablity Constructer with a reportItem
    public Vulnerability(ReportItem reportItem) {
        Port = reportItem.port;
        pluginName = reportItem.pluginName;
        riskFactor = reportItem.riskFactor;
        solution = reportItem.solution;
        synopsis = reportItem.synopsis;
        description = reportItem.description;
        cvssBaseScore = reportItem.cvssBaseScore;
        cvssTempScore = reportItem.cvssTemporalScore;
    }


    //    this static function will take a Nessus Object and give a list of vulnerabilities which is ready to make report from.
    public static List<Vulnerability> FromNessus(Nessus n) {
        List<String> vulnerabilityNames = getNamesOfVulnerabilities(n);     // Get a list of unique Vulnerability name from the nessus file
        List<Vulnerability> vulnerabilities = GetVulnerabilities(n, vulnerabilityNames);    //Make a list of Vulnerability from corresponding list of name of vulnerability
        List<Vulnerability> mergedVulnerabilites = mergeList(vulnerabilities);      //Merge the vulnerabilities which are similar
        Sanitize(mergedVulnerabilites);     //Sanitize each vulnerabilities ie. Changes the name, solution etc of vulnerability if needed.
        return mergedVulnerabilites;
    }

    private static String getID(ReportHost rh) {
        String id = "";
        if (showIP) id += rh.name;
        if (showMAC && (!rh.hostProperties.getTag("mac-address").contains("@@@NA") || showNA))
            id += " (" + rh.hostProperties.getTag("mac-address") + ")";
        if (showNetBios && (!rh.hostProperties.getTag("netbios-name").contains("@@@NA") || showNA))
            id += " (" + rh.hostProperties.getTag("netbios-name") + ")";
        return id;
    }

    //Make a list of Vulnerability from corresponding list of name of vulnerability
    private static List<Vulnerability> GetVulnerabilities(Nessus n, List<String> l) {
        List<Vulnerability> vl = new LinkedList<>();
        for (String vn : l) {
            Vulnerability vulTmp = new Vulnerability();
            boolean firstTmpVuln = true;
            for (ReportHost rh : n.report.reportHosts)
                for (ReportItem ri : rh.reportItems)
                    if (ri.plugin_name.equals(vn)) {
//                To Make MAC or NetBios Based Report Change the line below.
                        String tempID = getID(rh); // identifier such as ip,MAC,NetBios
                        if (firstTmpVuln) {
                            vulTmp = new Vulnerability(ri);
                            vulTmp.IPs.add(tempID);
                            firstTmpVuln = false;
                        } else
                            vulTmp.IPs.add(tempID);
                    }
            vulTmp.IPs = Vulnerability.removeDuplicates(vulTmp.IPs);
            Collections.sort(vulTmp.IPs);
            vl.add(vulTmp);
        }
        return vl;
    }

    // Get a list of unique Vulnerability name from the nessus file
    private static List<String> getNamesOfVulnerabilities(Nessus n) {
        List<String> vulnNameList = new LinkedList<>();
        for (ReportHost rh : n.report.reportHosts)
            for (ReportItem ri : rh.reportItems)
                if (!ri.cvssBaseScore.equals("@@@NA"))      // Sometimes cvssBaseScore for a vulnerability is Not Given , ie cvssBaseScore=@@@NA and it can't be parsed to Float
                    if (Float.parseFloat(ri.cvssBaseScore) > 0) //Basically gives every vulnerablity with a CVSS Base Score
                        if (!notNeededVulns.contains(ri.plugin_name))   //Checks if vulnerability is needed in to put in the report comparing a list.
                            vulnNameList.add(ri.pluginName);    //if the vulnerability is needed then adds the vulnerability name to the list.

        vulnNameList = Vulnerability.removeDuplicates(vulnNameList);    //this list may contain multiple duplicate vulnerability name, it removes duplicates.
        return vulnNameList;
    }

    //    Merge the vulnerabilities which are similar
    private static List<Vulnerability> mergeList(List<Vulnerability> vl) {
        List<Vulnerability> tmpVulnList = new LinkedList<>();
        List<Vulnerability> criticalVulnerabilities = new LinkedList<>();   // only a vulnerability of same risk factor ie Critical, High or Medium
        List<Vulnerability> highVulnerabilities = new LinkedList<>();       // so different list of vulnerability according to risk factor is made.
        List<Vulnerability> mediumVulnerabilities = new LinkedList<>();
        for (Vulnerability v : vl) {
            if (v.riskFactor.equals("Critical"))
                criticalVulnerabilities.add(v);        //  each vulnerability is put to either of the list according
            if (v.riskFactor.equals("High"))
                highVulnerabilities.add(v);                // to it's criticality or risk factor.
            if (v.riskFactor.equals("Medium")) mediumVulnerabilities.add(v);
        }
        if (!criticalVulnerabilities.isEmpty())
            tmpVulnList.addAll(mergeSameRiskFactorVulnerability(criticalVulnerabilities));
        if (!highVulnerabilities.isEmpty())
            tmpVulnList.addAll(mergeSameRiskFactorVulnerability(highVulnerabilities));
        if (!mediumVulnerabilities.isEmpty())
            tmpVulnList.addAll(mergeSameRiskFactorVulnerability(mediumVulnerabilities));
        return tmpVulnList;
    }

    private static List<Vulnerability> mergeSameRiskFactorVulnerability(List<Vulnerability> vl) {
        List<Vulnerability> tmpVulnList = new LinkedList<>();
        List<Vulnerability> phpVulns = new LinkedList<>();
        List<Vulnerability> openSSLVulns = new LinkedList<>();
        List<Vulnerability> apacheVulns = new LinkedList<>();
        for (Vulnerability v : vl) {
            if (v.pluginName.contains("PHP ") && v.pluginName.contains("<"))
                phpVulns.add(v);
            else if (v.pluginName.contains("Apache ") && v.pluginName.contains("<"))
                apacheVulns.add(v);
            else if (v.pluginName.contains("OpenSSL ") && v.pluginName.contains("<"))
                openSSLVulns.add(v);
            else
                tmpVulnList.add(v);
        }
        if (!phpVulns.isEmpty())
            tmpVulnList.add(mergeSameKindOfVulnerability(phpVulns));
        if (!apacheVulns.isEmpty())
            tmpVulnList.add(mergeSameKindOfVulnerability(apacheVulns));
        if (!openSSLVulns.isEmpty())
            tmpVulnList.add(mergeSameKindOfVulnerability(openSSLVulns));
        return tmpVulnList;
    }

    private static Vulnerability mergeSameKindOfVulnerability(List<Vulnerability> vl) {
        Collections.sort(vl);
        Vulnerability tmpVuln = new Vulnerability(vl.get(0));
        for (Vulnerability v : vl)
            tmpVuln.IPs.addAll(v.IPs);
        tmpVuln.IPs = Vulnerability.removeDuplicates(tmpVuln.IPs);
        Collections.sort(tmpVuln.IPs);
        return tmpVuln;
    }

    public static void Print(Vulnerability v) {
//        System.out.println("=======================================");
        System.out.println(v.pluginName);// + "(" + v.IPs.get(0) + ") " + v.cvssBaseScore + "  " + v.cvssTempScore);
//        System.out.println(v.IPs.toString());
    }

    private static LinkedList<String> removeDuplicates(List<String> list) {
        LinkedList<String> result = new LinkedList<String>();
        HashSet<String> set = new HashSet<String>();
        for (String item : list) {
            if (set.contains(item)) continue;
            result.add(item);
            set.add(item);
        }
        return result;
    }

    @Override
    public int compareTo(Vulnerability o) {
        if (Float.parseFloat(this.cvssBaseScore) < Float.parseFloat(o.cvssBaseScore))
            return 1;
        if (Float.parseFloat(this.cvssBaseScore) > Float.parseFloat(o.cvssBaseScore))
            return -1;
        return 0;
    }

    private static void Sanitize(List<Vulnerability> vl) {
        for (Vulnerability v : vl)
            Sanitize(v);
    }

    private static void Sanitize(Vulnerability v) {
        sanitizeMSXX0XXVulns(v);
        sanitizePHPVulns(v);
    }

    private static void sanitizeMSXX0XXVulns(Vulnerability v) {
        v.pluginName = v.pluginName
                .replace("(uncredentialed check)", "") //removes "(uncredentialed check)" and
                .replace("(remote check)", "");         //"(remote check)" from the vulnerability name
        Pattern p = Pattern.compile("\\((.*?)\\)");
        Matcher m = p.matcher(v.pluginName);
        while (m.find()) {
            try {
                Double.parseDouble(m.group(1));
                v.pluginName = v.pluginName.replace(m.group(1), "").replace("()", ""); //revmoves (*****) pattern from Vulnerability Name
            } catch (Exception e) {
            }
        }


        Pattern p1 = Pattern.compile("MS(.*?):");
        Matcher m1 = p1.matcher(v.pluginName);
        while (m1.find()) {
            try {
                String tempTag = m1.group(0);   //In MSXX-0XX vulnerability such as MS14-066, the solution is like "Microsoft has released the patch for this-this OS" but we
                tempTag = tempTag.replace(":", ""); //should give the link to the patch so this will give the link. like https://technet.microsoft.com/en-us/library/security/ms14-066
                v.solution = "<p align=\"left\">Install the patch as per <br/>https://technet.microsoft.com/en-us/library/security/" + tempTag + "</p>";
            } catch (Exception tempTag) {
            }
        }

    }

    private static void sanitizePHPVulns(Vulnerability v) {

    }


}

class Host {
    //    these are the properties of a vulnerability
    public String IP = "@@@NA";
    public List<Vulnerability> vulnerabilitiesInHost = new LinkedList<>();

    public Host() {
    }

    public Host(String i) {
        IP = i;
    }

    public static List<Host> getHostsWithVulnerabilities(List<Vulnerability> vulnerabilityList) {
        List<String> hostsIPs = new LinkedList<>();
        List<Host> hostList = new LinkedList<>();

        for (Vulnerability v : vulnerabilityList)
            hostsIPs.addAll(v.IPs);
        hostsIPs = removeDuplicates(hostsIPs);
        Collections.sort(hostsIPs);

        for (String ip : hostsIPs) {
            Host host = new Host(ip);
            for (Vulnerability v : vulnerabilityList) {
                if (v.IPs.contains(ip)) {
                    host.vulnerabilitiesInHost.add(v);
                }
            }
            if (host.vulnerabilitiesInHost.size() > 0)
                hostList.add(host);
        }
        return hostList;
    }

    private static LinkedList<String> removeDuplicates(List<String> list) {
        LinkedList<String> result = new LinkedList<String>();
        HashSet<String> set = new HashSet<String>();
        for (String item : list) {
            if (set.contains(item)) continue;
            result.add(item);
            set.add(item);
        }
        return result;
    }

    public static void Print(Host host) {
        System.out.println("=======================================");
        System.out.println(host.IP);
        for (Vulnerability v : host.vulnerabilitiesInHost)
            System.out.println(v.pluginName);
//        System.out.println(v.IPs.toString());
    }
}